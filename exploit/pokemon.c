// Copyright 2016 FIX94
// This code is licensed to you under the terms of the GNU LGPL, version 3;
// see file LICENSE or http://www.gnu.org/licenses/lgpl-3.0.txt

#include "loader.h"

#define TO_ARAM 0
#define TO_MRAM 1

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef volatile unsigned int vu32;
typedef volatile unsigned short vu16;

static char *card_block;
static void (*oswakeupthread)(u32 cb);
static void (*ossleepthread)(u32 cb);

typedef struct _cInfo
{
    int chan;
    int fnum;
    int offset;
    int length;
    u16 block;
} cInfo;

typedef struct _cStat
{
    char name[32];
    int length;
    char dontcare[44];
} cStat;

static void sync_cache(void *p, u32 n)
{
	u32 start, end;

	start = (u32)p & ~31;
	end = ((u32)p + n + 31) & ~31;
	n = (end - start) >> 5;

	while (n--) {
		asm("dcbst 0,%0 ; icbi 0,%0" : : "b"(p));
		p += 32;
	}
	asm("sync ; isync");
}

void *_memcpy(void *ptr, const void *src, int size)
{
	char* ptr2 = ptr;
	const char* src2 = src;
	while(size--) *ptr2++ = *src2++;
	return ptr;
}

void ar_dma(u32 type, u32 mram, u32 aram, u32 len)
{
	*(vu16*)0xCC005020 = (mram>>16);
	*(vu16*)0xCC005022 = (mram&0xFFFF);
	*(vu16*)0xCC005024 = (aram>>16);
	*(vu16*)0xCC005026 = (aram&0xFFFF);
	*(vu16*)0xCC005028 = (type<<15)|(len>>16);
	*(vu16*)0xCC00502A = (len&0xFFFF);
	while(*(vu16*)0xCC00500A & 0x200) ;
}

void card_sync_cb()
{
	// process is done, wake up our main
	oswakeupthread((u32)(card_block+0x8C));
}

void card_sync()
{
	// sleeps until result is not -1 anymore
	do {
		ossleepthread((u32)(card_block+0x8C));
	} while(*(int*)(card_block+4) == -1);
}

// abs_start still is left over from JumpToPCDataCode
void __attribute__ ((noreturn)) _main(u32 abs_start)
{
	char *gameid = (char *)0x80000000;
	int (*card_mountasync)(int chan, void* workArea, void *cb1, void *cb2);
	int (*card_unmount)(int chan);
	int (*card_fastopen)(int chan, int fnum, cInfo* inf);
	int (*card_close)(cInfo *inf);
	int (*card_readasync)(cInfo *inf, void* addr, int length, int offset, void *cb);
	int (*card_getstat)(int chan, int fnum, cStat* stat);
	void (*audio_stop)(void);
	void (*graphics_stop)(void);

	//Pokemon XD
	if(gameid[1] == 'X' && gameid[2] == 'X')
	{
		switch (gameid[3]) {
		case 'E':
			audio_stop = (void*)0x800AAB58;
			ossleepthread = (void*)0x800B1F18;
			oswakeupthread = (void*)0x800B2004;
			card_mountasync = (void*)0x800C3A08;
			card_unmount = (void*)0x800C3C44;
			card_fastopen = (void*)0x800C4948;
			card_close = (void*)0x800C4A4C;
			card_readasync = (void*)0x800C50E0;
			card_getstat = (void*)0x800C5990;
			graphics_stop = (void*)0x800C970C;
			card_block = (char*)0x8043E840;
			break;
		case 'P':
			audio_stop = (void*)0x800AC0A0;
			ossleepthread = (void*)0x800B3570;
			oswakeupthread = (void*)0x800B365C;
			card_mountasync = (void*)0x800C5024;
			card_unmount = (void*)0x800C5260;
			card_fastopen = (void*)0x800C5F64;
			card_close = (void*)0x800C6068;
			card_readasync = (void*)0x800C66FC;
			card_getstat = (void*)0x800C6FAC;
			graphics_stop = (void*)0x800CAD28;
			card_block = (char*)0x80478E20;
			break;
		case 'J':
			audio_stop = (void*)0x800A6FEC;
			ossleepthread = (void*)0x800AE3AC;
			oswakeupthread = (void*)0x800AE498;
			card_mountasync = (void*)0x800BFF2C;
			card_unmount = (void*)0x800C0168;
			card_fastopen = (void*)0x800C0E6C;
			card_close = (void*)0x800C0F70;
			card_readasync = (void*)0x800C1604;
			card_getstat = (void*)0x800C1EB4;
			graphics_stop = (void*)0x800C5C30;
			card_block = (char*)0x8041BD60;
			break;
		default:
			for (;;)
				;
		}
	}
	else //Pokemon Colosseum
	{
		switch (gameid[3]) {
		case 'E':
			audio_stop = (void*)0x8009B1B8;
			ossleepthread = (void*)0x800A238C;
			oswakeupthread = (void*)0x800A2478;
			card_mountasync = (void*)0x800B373C;
			card_unmount = (void*)0x800B3978;
			card_fastopen = (void*)0x800B4488;
			card_close = (void*)0x800B45E8;
			card_readasync = (void*)0x800B4C7C;
			card_getstat = (void*)0x800B5530;
			graphics_stop = (void*)0x800B8AE8;
			card_block = (char*)0x803FC620;
			break;
		case 'P':
			audio_stop = (void*)0x8009E6E0;
			ossleepthread = (void*)0x800A59C8;
			oswakeupthread = (void*)0x800A5AB4;
			card_mountasync = (void*)0x800B6D3C;
			card_unmount = (void*)0x800B6F78;
			card_fastopen = (void*)0x800B7A88;
			card_close = (void*)0x800B7BE8;
			card_readasync = (void*)0x800B827C;
			card_getstat = (void*)0x800B8B30;
			graphics_stop = (void*)0x800BC0E8;
			card_block = (char*)0x80449AA0;
			break;
		case 'J':
			audio_stop = (void*)0x80098E64;
			ossleepthread = (void*)0x800A0038;
			oswakeupthread = (void*)0x800A0124;
			card_mountasync = (void*)0x800B13E8;
			card_unmount = (void*)0x800B1624;
			card_fastopen = (void*)0x800B2134;
			card_close = (void*)0x800B2294;
			card_readasync = (void*)0x800B2928;
			card_getstat = (void*)0x800B31DC;
			graphics_stop = (void*)0x800B6794;
			card_block = (char*)0x803E8CE0;
			break;
		default:
			for (;;)
				;
		}
	}
	//prevent BEEPing
	audio_stop();
	graphics_stop();
	//only hand over absolute position of this function to CARD
	void *card_sync_cb_abs = (void*)(((u32)card_sync_cb)+abs_start);
	//mount CARD (abuse 0x80800000 for work memory)
	if(card_mountasync(0, (void*)0x80800000, (void*)0, card_sync_cb_abs) >= 0)
		card_sync();
	//find out boot.dol position on memory card
	int i;
	cStat stat;
	for(i = 0; i < 127; i++)
	{
		if(card_getstat(0,i,&stat) != 0)
			continue;
		u32 *cmpName = (u32*)stat.name;
		//boot.dol string in int form
		if(cmpName[0] == 0x626F6F74 && cmpName[1] == 0x2E646F6C && cmpName[2] == 0)
			break;
	}
	//open the position
	cInfo mInf;
	card_fastopen(0,i,&mInf);
	u32 curOffset = 0;
	//read amount set in stat.length
	while(stat.length > 0)
	{
		if(card_readasync(&mInf, (void*)0x80001800, 0x200, curOffset, card_sync_cb_abs) >= 0)
			card_sync();
		sync_cache((void*)0x80001800, 0x200);
		ar_dma(TO_ARAM, 0x1800, curOffset, 0x200);
		curOffset += 0x200;
		stat.length -= 0x200;
	}
	//we are done
	card_close(&mInf);
	card_unmount(0);
	//copy our loader into mem
	void *loader_abs = (void*)(((u32)loader)+abs_start);
	_memcpy((void*)0x80001800, loader_abs, loader_size);
	sync_cache((void*)0x80001800, loader_size);
	//jump to it
	__asm__ volatile(
		"lis 3, 0x8000\n"
		"ori 3, 3, 0x1800\n"
		"mtlr 3\n"
		"blr\n"
	);
	__builtin_unreachable();
}
